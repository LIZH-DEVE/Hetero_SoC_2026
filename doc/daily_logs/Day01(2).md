# Project Hetero_SoC: Day 1(2) - The CDC Airlock

> **Date:** 2026-01-22 (Beijing Time)
> **Status:** RTL Implementation & Static Audit Passed
> **Author:** CS to IC Transformer

## 1. 项目概述 (Overview)

Day 2 的任务是攻克芯片设计中最危险的领域——**跨时钟域 (CDC, Clock Domain Crossing)**。
**核心目标**：构建一个双时钟异步 FIFO，作为异构 SoC 中不同频率模块（如 CPU 与 加密核）之间的安全数据缓冲。
**战略意义**：这是对“亚稳态 (Metastability)”的物理防御战。如果 Day 1 是定义语言，Day 2 就是在构建让系统不崩溃的物理法则。

## 2. 开发环境 (Environment)

* **IDE**: Xilinx Vivado 2024.1
* **Editor**: VS Code (SystemVerilog Support)
* **Version Control**: Git / GitHub (Feature Branch Workflow)
* **Language**: SystemVerilog (IEEE 1800-2017)

## 3. 理论军火库 (CDC Knowledge Base)

为了解决异步时钟带来的数据丢失和系统死锁风险，我们在 RTL 中固化了以下物理概念：

### A. 亚稳态 (Metastability)

* **物理本质**：当信号在时钟采样的“建立时间”或“保持时间”窗口内跳变时，触发器输出会在 0 和 1 之间震荡。
* **后果**：这种震荡会像病毒一样传播到后级逻辑，导致整个芯片随机瘫痪。
* **对策**：硬件无法消除亚稳态，只能通过技术手段（2-FF）降低其发生概率。

### B. 格雷码 (Gray Code)

这是解决多位宽指针跨时钟域的唯一数学解。

* **二进制痛点**：`011 (3)` -> `100 (4)` 有 3 个 bit 同时翻转。由于线路延迟不同，采样端可能抓到 `111` 或 `000` 等错误中间态。
* **格雷码特性**：相邻数值**仅有 1 bit 翻转**。
* **公式**：`Gray = (Binary >> 1) ^ Binary`
* **实战价值**：即使采样落在跳变瞬间，结果只能是“旧值”或“新值”，绝不会出现逻辑错误。

### C. 两级同步器 (2-FF Synchronizer)

* **机制**：将异步信号串联通过两个 D 触发器。
* **原理**：第一级触发器可能进入亚稳态，但经过一个时钟周期的“沉降”，第二级输出稳定电平的概率接近 100%。
* **代码映射**：`{s2, s1} <= {s1, input_gray}`

## 4. 模块定义 (Design Specifications)

### 核心模块: `async_fifo.sv`

这是一个拥有两个独立时钟域（Read Domain & Write Domain）的存储与控制单元。

| 端口名 | 方向 | 时钟域 | 描述 |
| :--- | :--- | :--- | :--- |
| `wclk` | input | Write | 写时钟 (生产者频率) |
| `wdata` | input | Write | 写入数据 (Payload) |
| `wfull` | output | Write | **满标志** (反压信号，停止写入) |
| `rclk` | input | Read | 读时钟 (消费者频率) |
| `rdata` | output | Read | 读出数据 |
| `rempty` | output | Read | **空标志** (停止读取) |

### 逻辑功能表 (Logic Truth Table)

| 状态 | 判断逻辑 (基于格雷码) | 物理意义 |
| :--- | :--- | :--- |
| **Empty (空)** | `rptr_gray == wptr_gray_sync` | 读指针追上了写指针，没数据了。 |
| **Full (满)** | `wptr == {~rptr[N:N-1], rptr[N-2:0]}` | 写指针比读指针快了一整圈 (最高两位翻转)。 |
| **Write** | `wen && !wfull` | 只有“未满”且“使能”时，才允许写入 RAM。 |
| **Read** | `ren && !rempty` | 只有“非空”且“使能”时，才允许更新读指针。 |

## 5. 验证与仿真 (Verification)

### 静态审计 (Static Audit)

* **Syntax Check**: Passed (Vivado & VS Code Language Server).
* **Logic Check**:
    * 确认使用了 `always_ff` 描述时序逻辑，确保综合为触发器。
    * 确认 RAM 读取使用了组合逻辑 `assign`，保证数据即时性。
    * 确认所有跨时钟域的指针都经过了 `bin -> gray -> 2-ff` 的完整链路。

### 待办验证 (Next Step)

* **Testbench**: 尚未编写。Day 3 将模拟 `Write_Fast_Read_Slow` 和 `Write_Slow_Read_Fast` 两种极端场景进行波形验证。

## 6. 核心认知升级 (Key Learnings)

1.  **CS vs IC 的同步观**：
    * CS (软件)：使用 `Mutex` (互斥锁) 或 `Semaphore` (信号量) 保护共享内存。
    * IC (硬件)：不能让信号“停下来”等锁，必须用 `FIFO` 和 `Gray Code` 在流动中完成同步。
2.  **数据的生命周期**：数据不仅需要被“计算”，更需要被“安全地传输”。`async_fifo` 就是数据的“气闸舱”。
3.  **多出的那一位**：指针位宽设计为 `ADDR_WIDTH + 1`，这是为了在格雷码域区分“这一圈”和“下一圈”，是判断 Full/Empty 的几何基础。

## 7. 顾问评价 (Advisor's Note)

> "Day 2 你触碰了数字电路设计的‘深水区’。大多数初学者只会在同一个时钟下写逻辑，而你构建了一座跨越频率的桥梁。虽然代码写完了，但请记住：**未经波形验证的代码只是文本文件**。Day 3 的 Testbench 才是对你逻辑的终极审判。"

---

*Generated by Gemini - Your Brutally Honest Advisor*