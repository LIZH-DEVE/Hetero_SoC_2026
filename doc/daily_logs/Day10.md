# Project Pre-Burn: Day 10 - The "Echo" of the Machine

> **Date:** 2026-01-29 (US Pacific Time)
> **Status:** Simulation Passed / Logic Closed (Loopback Verified)
> **Author:** Future IC Engineer

## 1. 项目概述 (Overview)

本项目是《预燃行动 (Project Pre-Burn)》的第十天里程碑。
**核心目标**：完成网络协议栈的“闭环”，从单纯的“听众”进化为“演说家”。
**战略意义**：
1.  **主动发包 (TX Capability)**：实现了完整的 Ethernet/IP/UDP 组包逻辑，不再依赖硬编码波形。
2.  **硬件卸载 (Checksum Offload)**：在流水线中实时计算 IPv4 校验和，解放 CPU 算力。
3.  **智能回显 (Info Swap)**：实现了类似 Ping 的 Echo 机制，自动提取接收包的源地址并作为发送包的目的地址。

## 2. 开发环境 (Environment)

* **IDE**: Xilinx Vivado 2024.1
* **Language**: SystemVerilog (RTL + Verification)
* **Simulation**: Vivado Simulator (XSim) with Self-Checking Monitor

## 3. 理论军火库 (Knowledge Base)

在 Day 10 中，我们将以下网络协议的“硬骨头”转化为电路逻辑：

### A. 校验和卸载 (Checksum Offload)
* **痛点**：IPv4 Header Checksum 需要对包头所有 16-bit 字进行反码求和。如果在发送前由 CPU 计算，会极大增加延迟。
* **解法**：**Store-and-Forward (存储转发)**。
    * 利用 PBM 缓存数据，TX 引擎在读取数据前先行计算 Checksum。
    * 使用组合逻辑 (`always_comb`) 实现并行加法树，单周期完成计算。

### B. 最小帧填充 (Padding Logic)
* **规则**：Ethernet 标准规定最小帧长为 64 字节（含 4 字节 FCS）。如果不含 FCS，Payload + Header 至少需要 60 字节。
* **实现**：
    * 当有效载荷 (`Payload`) 过短（如 4 字节）时，状态机进入 `SEND_PAD` 状态。
    * 发送 `0x00` 直到计数器满足 60 字节要求，再拉高 `TLAST`。

### C. 地址交换 (Info Swap)
* **逻辑**：为了实现 Ping-Pong 测试，FPGA 必须“记得”是谁发来的包。
    * **RX 阶段**：`rx_parser` 提取 `Src_MAC`, `Src_IP`, `Src_Port` 并存入寄存器。
    * **TX 阶段**：`tx_stack` 读取这些寄存器，将其填入 `Dst_MAC`, `Dst_IP`, `Dst_Port` 字段。

## 4. 模块定义与架构 (Specs & Architecture)

### 核心模块: `tx_stack.sv`
负责将 PBM 中的纯数据封装为合法的 UDP/IP/Ethernet 帧。

### 顶层架构更新: `dma_subsystem.sv`
打通了 RX 到 TX 的直接数据通路（Bypass Crypto for Day 10 validation）：

| 阶段 | 动作 | 数据流向 | 关键信号 |
| :--- | :--- | :--- | :--- |
| **1. Receive** | 解析与提取 | MAC -> RX Parser -> PBM | `rec_src_ip` (Latching) |
| **2. Buffer** | 存储 | PBM (Packet Buffer Memory) | `o_rd_empty` |
| **3. Config** | CPU 启动 | AXI-Lite CSR -> TX Stack | `dma_start_csr` |
| **4. Transmit**| 组包与发送 | TX Stack -> MAC | `tx_axis_tdata` (Swapped) |

### 状态机视图 (FSM View)
`IDLE` -> `CALC_CSUM` -> `SEND_ETH` -> `SEND_IP` -> `SEND_UDP` -> `SEND_PAYLOAD` -> `SEND_PAD` -> `DONE`

## 5. 验证与审计 (Verification & Audit)

### 仿真状态 (Simulation) - *Passed*
* **Testbench**: `tb_dma_subsystem.sv` (Self-Checking Version)
* **测试用例**:
    1.  **Inject**: 发送 Src IP = `192.168.1.1` (C0 A8 01 01), Payload = 4 Bytes.
    2.  **Trigger**: 配置 CSR 启动发送。
    3.  **Check**: Monitor 自动捕获 TX 数据。

### 关键波形证据 (Evidence)
1.  **Info Swap**: TX 输出的 Dst IP 为 `C0 A8 01 01` (成功回显)。
2.  **Checksum**: IP Header 第 10-11 字节非零且正确。
3.  **Padding**: 虽然 Payload 仅 4 字节，但 `TLAST` 延迟拉高，补齐了 `00`。
4.  **Handshake**: 修复了 AXI-Lite `BREADY` 导致的死锁，CSR 配置顺畅。

## 6. 核心认知升级 (Key Learnings)

1.  **死锁的教训 (Deadlock)**：
    * AXI-Lite 接口中，Master 必须拉高 `BREADY` 才能接收 Slave 的写响应。忽略这一点会导致 CPU 卡死在写操作，TX 永远无法启动。
2.  **协议对齐的严谨性**：
    * `rx_parser` 对输入数据的字节位置极其敏感。Testbench 构造数据包时，如果 `0x0800` (EtherType) 错位一个字节，整个包都会被丢弃 (Drop)，导致 PBM 为空，TX 饿死。
3.  **Tie-off 的艺术**：
    * 对于 AXI Master 中未使用的读通道 (`AR`, `R`)，必须显式地进行 Tie-off (输入置固值，输出悬空)，否则会导致仿真器报错或逻辑未定义。

## 7. 顾问评价 (Advisor's Note)

> "Day 10 标志着你从‘数字逻辑设计’跨越到了‘网络协议栈设计’。
>
> 能够处理 Padding 和 Checksum，意味着你的设计已经具备了与真实世界网络设备对话的能力。
> 特别值得表扬的是你最终解决 CSR 死锁和 RX 注入协议对齐问题的过程——**硬件调试没有魔法，只有对时序和协议的绝对尊重。**
>
> 下一步：Day 11，把 Crypto Engine 放回来。让这个回声，变成加密的回声。"

---

*Generated by Gemini - Your Brutally Honest Advisor*